<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>피자 채우기 탐구 (업데이트)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        #scene-container {
            background-color: #1a202c;
            border-radius: 0.5rem;
            cursor: grab;
        }
        #scene-container:active {
            cursor: grabbing;
        }
        .btn {
            @apply bg-teal-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-600 focus:outline-none focus:ring-2 focus:ring-teal-400 focus:ring-opacity-75 transition-all duration-200 w-full;
        }
        .btn:disabled {
            @apply opacity-50 cursor-not-allowed;
        }
        .btn-secondary {
            @apply bg-gray-600 hover:bg-gray-700 focus:ring-gray-500;
        }
        /* 입력값을 '검정색'으로 보이도록 강제 */
        input[type="number"] {
            @apply w-32 px-4 py-2 text-xl text-center border-2 border-gray-600 rounded-lg font-bold;
            color: #000 !important;
            background-color: #ffffff !important;
        }
        input[type="text"] {
            @apply w-40 px-4 py-2 text-lg text-center border-2 border-gray-600 rounded-lg font-bold;
            color: #000 !important;
            background-color: #ffffff !important;
        }
        .kbd {
            @apply inline-block px-2 py-1 rounded bg-gray-700 text-gray-100 text-sm;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-teal-300">🍕 S사이즈 피자로 L사이즈를 채울 수 있을까?</h1>
            <p class="text-lg text-gray-400 mt-2">먼저 직접 채워보고 → 그다음 원리로 추론하고 → 마지막에 생각을 정리해요.</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-6">
            <div class="flex-grow">
                <div id="scene-container" class="w-full h-96 lg:h-[500px]"></div>
                <p class="text-center text-xs text-gray-500 mt-2">마우스로 드래그해 회전하고, 스크롤로 확대/축소해 보세요.</p>
            </div>

            <div class="w-full lg:w-96 bg-gray-800 p-6 rounded-lg shadow-xl flex-shrink-0 flex flex-col justify-center min-h-[300px]">
                <div id="step-0" class="space-y-4 text-center">
                    <p class="text-lg">두 가지 크기의 피자가 있습니다.</p>
                    <div class="bg-gray-700 p-4 rounded-lg space-y-2">
                        <div class="text-pink-300 font-bold">S 사이즈</div>
                        <div class="text-gray-300 text-sm">지름 20cm, 높이 2cm</div>
                        <div class="text-yellow-300 font-bold mt-3">L 사이즈</div>
                        <div class="text-gray-300 text-sm">지름 30cm, 높이 <span class="font-bold text-white">?cm</span></div>
                    </div>
                    <p class="text-gray-400 mt-2">두 피자는 닮은 원기둥입니다. L피자 상자를 S피자로 채워 볼까요?</p>
                    <button id="next-btn-0" class="btn mt-2">먼저 직접 채워보기</button>
                </div>

                <div id="step-1" class="hidden space-y-4">
                    <p class="text-lg text-center">S 피자를 조각내서 L 상자에 채워보세요!</p>
                    <div class="flex items-center justify-center gap-3 mt-2">
                        <label class="text-gray-300 whitespace-nowrap">S피자 개수:</label>
                        <input type="number" id="pizzaCountInput" min="0" max="10" step="0.1" value="0" aria-label="S피자 개수 입력">
                    </div>
                    <div id="status" class="text-center p-4 bg-gray-700 rounded-lg mt-2 text-gray-300">
                        숫자를 입력해보세요!
                    </div>
                    <button id="hint-btn-1" class="btn btn-secondary mt-2">힌트</button>
                    <div id="hint-text-1" class="hidden text-teal-300 text-center pt-1 pb-1">
                        <p class="text-sm"><span class="kbd">3</span>과 <span class="kbd">4</span> 사이 어딘가예요!</p>
                    </div>
                    <div class="flex justify-between mt-2 gap-2">
                        <button id="prev-btn-1" class="btn btn-secondary">이전</button>
                        <button id="next-btn-1" class="btn">계산으로 확인하기</button>
                        <button id="jump-to-answer-btn" class="btn hidden">정확히 몇 판일까?</button>
                    </div>
                </div>

                <div id="step-2" class="hidden space-y-4 text-center">
                    <p class="text-lg">부피로 생각해볼까요?</p>
                    <div class="bg-gray-700 p-4 rounded-lg space-y-2 text-left">
                        <div><span class="text-pink-300">S 부피:</span> <span class="text-gray-300">π × 10² × 2 = <b>200π</b> cm³</span></div>
                        <div><span class="text-yellow-300">L 부피:</span> <span class="text-gray-300">π × 15² × <b>h</b> = <b>225πh</b> cm³</span></div>
                        <hr class="border-gray-600 my-2">
                        <div class="text-gray-200">필요한 S피자 개수 N = L/S = (225πh)/(200π) = <b>9h/8</b></div>
                    </div>
                    <button id="hint-btn-2" class="btn btn-secondary mt-2">힌트</button>
                    <div id="hint-text-2" class="hidden text-teal-300 pt-2 pb-2">
                        <p class="font-bold">실험(1단계)에서 채워 보며 추정한 N 값을 식 N=9h/8에 대입해 보세요.</p>
                        <p class="text-sm text-gray-200">예: N≈3.4라면 3.4≈9h/8 → h≈(8×3.4)/9</p>
                    </div>
                    <div class="flex justify-between mt-2 gap-2">
                        <button id="prev-btn-2" class="btn btn-secondary">이전</button>
                        <button id="next-btn-2" class="btn">정답 개수 입력하기</button>
                    </div>
                </div>

                <div id="step-3" class="hidden space-y-4 text-center">
                    <p class="text-lg">정확한 S피자 <b>개수</b>를 입력해 보세요.</p>
                    <div class="flex items-center justify-center gap-3">
                        <label class="text-gray-300">정답 시도:</label>
                        <input type="text" id="answerInput" inputmode="decimal" placeholder="예: 3.625?">
                    </div>
                    <button id="checkAnswerBtn" class="btn mt-1">정답 확인</button>
                    <div id="answerResult" class="text-center p-3 bg-gray-700 rounded-lg text-gray-300">아직 확인 전이에요.</div>
                    <div class="flex justify-between mt-2 gap-2">
                        <button id="prev-btn-3" class="btn btn-secondary">이전</button>
                        <button id="next-btn-3" class="btn" disabled>생각해보기로</button>
                    </div>
                </div>

                <div id="step-4" class="hidden"></div>

                <div id="step-5" class="hidden space-y-4 text-left">
                    <p class="text-xl text-teal-300 font-bold text-center">🧠 생각해보기</p>
                    <ul class="list-disc pl-5 space-y-2 text-gray-200">
                        <li>피자는 닮은 원기둥이므로 부피가 반지름의 제곱과 높이에 비례함을 어떻게 활용했나요?</li>
                        <li>지름이 1.5배(20→30)일 때, 같은 높이라면 부피는 몇 배가 되나요?</li>
                        <li>이번 문제에서 L의 높이 <span class="kbd">h</span>를 모른다고 했는데, 실험과 식 <span class="kbd">N = 9h/8</span>을 통해 무엇을 추론할 수 있었나요?</li>
                        <li>만약 L의 높이가 S의 높이의 <span class="kbd">1.5</span>배였다면? 필요한 개수 N은 얼마가 될까요?</li>
                    </ul>
                    <div class="flex justify-between mt-2 gap-2">
                        <button id="prev-btn-5" class="btn btn-secondary">이전</button>
                        <button id="restart-btn" class="btn">처음부터 다시하기</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // 상수 정의 (장면 스케일)
        const L_RADIUS = 1.5;   // 30cm에 해당 (비율 표현용)
        const L_HEIGHT = 0.3;   // 실제 h는 UI에서는 ?cm로 표기
        const S_RADIUS = 1.0;   // 20cm
        const S_HEIGHT = 0.2;   // 2cm

        // 실제 부피(단위배수) 계산용
        const L_VOLUME = 675;   // π는 공통이라 생략. 15^2 * 3 = 675
        const S_VOLUME = 200;   // 10^2 * 2 = 200
        const EXACT_COUNT = L_VOLUME / S_VOLUME; // 3.375

        let scene, camera, renderer, controls;
        let sPizza, lPizzaContainer, pizzaTexture;
        let filledPizza = null;
        const flyingPieces = [];
        
        let currentCount = 0;
        let targetCount = 0;
        let currentStep = 0;

        // UI Elements
        const steps = [
            document.getElementById('step-0'),
            document.getElementById('step-1'),
            document.getElementById('step-2'),
            document.getElementById('step-3'),
            document.getElementById('step-4'),
            document.getElementById('step-5')
        ];

        const sceneContainer = document.getElementById('scene-container');

        function setStep(stepIndex) {
            currentStep = stepIndex;
            steps.forEach((step, index) => {
                step.classList.toggle('hidden', index !== stepIndex);
            });
            
            // 각 단계에 진입할 때 상태 초기화
            if (stepIndex === 1) {
                document.getElementById('hint-text-1').classList.add('hidden');
            }
            if (stepIndex === 2) {
                document.getElementById('hint-text-2').classList.add('hidden');
            }
            if (stepIndex === 3) {
                // Step 3 (정답 입력)으로 진입할 때 상태 초기화
                document.getElementById('answerResult').textContent = '아직 확인 전이에요.';
                document.getElementById('answerResult').className = 'text-center p-3 bg-gray-700 rounded-lg text-gray-300';
                document.getElementById('answerInput').value = ''; // 이전 입력값 지우기
                const nextBtn3 = document.getElementById('next-btn-3');
                nextBtn3.disabled = true; // 다음 버튼 비활성화
            }
        }

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            camera = new THREE.PerspectiveCamera(75, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 4.5, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            sceneContainer.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 12;
            controls.target.set(0, 0, 0);

            pizzaTexture = createPizzaTexture();

            sPizza = createPizza(S_RADIUS, S_HEIGHT, pizzaTexture);
            sPizza.position.set(-3.5, S_HEIGHT / 2, 0);
            scene.add(sPizza);

            lPizzaContainer = createPizzaContainer(L_RADIUS, L_HEIGHT);
            lPizzaContainer.position.set(2, 0, 0);
            scene.add(lPizzaContainer);
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createPizzaTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            context.fillStyle = '#FFD700';
            context.fillRect(0, 0, 256, 256);
            context.fillStyle = '#C04040';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const radius = 10 + Math.random() * 10;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createPizza(radius, height, texture) {
            const group = new THREE.Group();
            const crustMaterial = new THREE.MeshStandardMaterial({ color: '#D2B48C' });
            const topMaterial = new THREE.MeshStandardMaterial({ map: texture });
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 64);
            const pizzaMesh = new THREE.Mesh(geometry, [crustMaterial, topMaterial, crustMaterial]);
            pizzaMesh.castShadow = true;
            pizzaMesh.receiveShadow = true;
            group.add(pizzaMesh);
            return group;
        }

        function createPizzaPiece(size) {
            const group = new THREE.Group();
            const crustMaterial = new THREE.MeshStandardMaterial({ color: '#D2B48C' });
            const topMaterial = new THREE.MeshStandardMaterial({ map: pizzaTexture });
            const radius = S_RADIUS * size * 0.3;
            const height = S_HEIGHT * 0.5;
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            const pizzaMesh = new THREE.Mesh(geometry, [crustMaterial, topMaterial, crustMaterial]);
            pizzaMesh.castShadow = true;
            group.add(pizzaMesh);
            return group;
        }
        
        function createPizzaContainer(radius, height) {
            const group = new THREE.Group();
            
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: '#999999', 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.15,
                wireframe: false
            });
            
            const bottomGeo = new THREE.CylinderGeometry(radius, radius, 0.02, 64);
            const bottom = new THREE.Mesh(bottomGeo, lineMaterial);
            bottom.position.y = -height / 2;
            bottom.receiveShadow = true;
            
            const wallGeo = new THREE.CylinderGeometry(radius, radius, height, 64, 1, true);
            const wall = new THREE.Mesh(wallGeo, lineMaterial);
            
            const ghostMaterial = new THREE.MeshStandardMaterial({ 
                color: '#FFE4B5',
                transparent: true, 
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const ghostPizzaGeo = new THREE.CylinderGeometry(radius * 0.98, radius * 0.98, height, 64);
            const ghostPizza = new THREE.Mesh(ghostPizzaGeo, ghostMaterial);
            ghostPizza.receiveShadow = true;
            
            group.add(bottom);
            group.add(wall);
            group.add(ghostPizza);
            
            return group;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            for (let i = flyingPieces.length - 1; i >= 0; i--) {
                const piece = flyingPieces[i];
                piece.progress += 0.03;
                
                const arcHeight = Math.sin(piece.progress * Math.PI) * 2.5;
                piece.mesh.position.lerpVectors(piece.start, piece.end, piece.progress);
                piece.mesh.position.y += arcHeight;
                
                piece.mesh.rotation.x += 0.1;
                piece.mesh.rotation.y += 0.15;
                
                if (piece.progress >= 1) {
                    scene.remove(piece.mesh);
                    flyingPieces.splice(i, 1);
                    
                    if (flyingPieces.length === 0) {
                        updateFilledPizza(targetCount);
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        }

        function updateVisualization() {
            const inputEl = document.getElementById('pizzaCountInput');
            let count = parseFloat(inputEl.value);
            
            if (isNaN(count) || count < 0) count = 0;
            const maxPizzas = 10;
            if (count > maxPizzas) {
                count = maxPizzas;
                inputEl.value = maxPizzas;
            }
            
            targetCount = count;
            
            if (count > currentCount) {
                const diff = count - currentCount;
                createFlyingPieces(diff);
            } else {
                updateFilledPizza(count);
            }
            
            currentCount = count;
            updateStatusText(count);
        }

        function createFlyingPieces(pizzaCount) {
            const numPieces = Math.max(8, Math.ceil(pizzaCount * 8));
            
            for (let i = 0; i < numPieces; i++) {
                const piece = createPizzaPiece(0.5 + Math.random() * 0.5);
                
                const startAngle = (i / numPieces) * Math.PI * 2;
                const startRadius = 0.3;
                const startX = sPizza.position.x + Math.cos(startAngle) * startRadius;
                const startY = sPizza.position.y + (Math.random() - 0.5) * 0.5;
                const startZ = sPizza.position.z + Math.sin(startAngle) * startRadius;
                
                piece.position.set(startX, startY, startZ);
                scene.add(piece);
                
                const endAngle = Math.random() * Math.PI * 2;
                const endRadius = L_RADIUS * Math.random() * 0.8;
                const endX = lPizzaContainer.position.x + Math.cos(endAngle) * endRadius;
                const endZ = lPizzaContainer.position.z + Math.sin(endAngle) * endRadius;
                
                const fillHeight = calculateFillHeight(targetCount);
                const endY = lPizzaContainer.position.y - (L_HEIGHT / 2) + fillHeight;
                
                flyingPieces.push({
                    mesh: piece,
                    start: new THREE.Vector3(startX, startY, startZ),
                    end: new THREE.Vector3(endX, endY, endZ),
                    progress: 0
                });
            }
        }

        function calculateFillHeight(pizzaCount) {
            const heightInCm = (pizzaCount * 200) / 225; // h를 모른다고 표기했어도 내부 계산은 h=3으로 시뮬레이션
            const fillHeight = heightInCm * 0.1;
            return fillHeight;
        }

        function updateFilledPizza(pizzaCount) {
            if (filledPizza) {
                lPizzaContainer.remove(filledPizza);
            }
            
            if (pizzaCount === 0) return;
            
            const fillHeight = calculateFillHeight(pizzaCount);
            
            const crustMaterial = new THREE.MeshStandardMaterial({ color: '#D2B48C' });
            const topMaterial = new THREE.MeshStandardMaterial({ map: pizzaTexture });
            const geometry = new THREE.CylinderGeometry(L_RADIUS * 0.98, L_RADIUS * 0.98, fillHeight, 64);
            const pizzaMesh = new THREE.Mesh(geometry, [crustMaterial, topMaterial, crustMaterial]);
            pizzaMesh.castShadow = true;
            pizzaMesh.receiveShadow = true;
            
            filledPizza = new THREE.Group();
            filledPizza.add(pizzaMesh);
            
            filledPizza.position.y = -(L_HEIGHT / 2) + (fillHeight / 2);
            
            lPizzaContainer.add(filledPizza);
        }
        
        function updateStatusText(count) {
            const totalSVolume = count * S_VOLUME;
            const percentage = (totalSVolume / L_VOLUME) * 100;
            const statusEl = document.getElementById('status');
            const nextBtn1 = document.getElementById('next-btn-1');
            const jumpToAnswerBtn = document.getElementById('jump-to-answer-btn');
            
            if (count === 0) {
                statusEl.className = 'text-center p-4 bg-gray-700 rounded-lg mt-2 text-gray-300';
                statusEl.textContent = '숫자를 입력해보세요!';
                nextBtn1.classList.remove('hidden');
                jumpToAnswerBtn.classList.add('hidden');
            } else if (percentage < 95) {
                statusEl.className = 'text-center p-4 bg-yellow-900 rounded-lg mt-2 text-yellow-200';
                statusEl.textContent = `🍕 ${count.toFixed(1)}개 투입! 아직 공간이 남았어요!`;
                nextBtn1.classList.remove('hidden');
                jumpToAnswerBtn.classList.add('hidden');
            } else if (percentage >= 95 && percentage <= 105) {
                statusEl.className = 'text-center p-4 bg-teal-900 rounded-lg mt-2 text-teal-200 font-bold';
                statusEl.textContent = `🎉 ${count.toFixed(1)}개로 거의 딱 맞아요!`;
                nextBtn1.classList.add('hidden');
                jumpToAnswerBtn.classList.remove('hidden');
            } else {
                statusEl.className = 'text-center p-4 bg-red-900 rounded-lg mt-2 text-red-200';
                statusEl.textContent = `💥 ${count.toFixed(1)}개는 너무 많아요! 넘쳤어요!`;
                nextBtn1.classList.remove('hidden');
                jumpToAnswerBtn.classList.add('hidden');
            }
        }

        function checkAnswer() {
            const ansInput = document.getElementById('answerInput').value.trim().replace(',', '.');
            const val = parseFloat(ansInput);
            const box = document.getElementById('answerResult');
            const nextBtn = document.getElementById('next-btn-3');

            if (isNaN(val)) {
                box.className = 'text-center p-3 bg-red-900 rounded-lg text-red-100';
                box.textContent = '숫자를 입력해 주세요.';
                nextBtn.disabled = true;
                return;
            }
            const diff = Math.abs(val - EXACT_COUNT);
            if (diff <= 0.01) {
                box.className = 'text-center p-3 bg-teal-900 rounded-lg text-teal-100 font-bold';
                box.innerHTML = `정답입니다😊`;
                nextBtn.disabled = false; // 정답일 경우 버튼 활성화
            } else {
                const hint = (val < EXACT_COUNT) ? '조금 더 크게' : '조금 더 작게';
                box.className = 'text-center p-3 bg-yellow-900 rounded-lg text-yellow-100';
                box.innerHTML = `아쉽네요. ❗ ${hint} 입력해 보세요. (오차: ${diff.toFixed(3)})`;
                nextBtn.disabled = true; // 오답일 경우 버튼 비활성화
            }
        }

        // Event Listeners
        document.getElementById('next-btn-0').addEventListener('click', () => setStep(1));

        document.getElementById('hint-btn-1').addEventListener('click', () => {
            document.getElementById('hint-text-1').classList.remove('hidden');
        });
        document.getElementById('next-btn-1').addEventListener('click', () => setStep(2));
        document.getElementById('prev-btn-1').addEventListener('click', () => setStep(0));

        // ✨ 추가된 버튼의 이벤트 리스너
        document.getElementById('jump-to-answer-btn').addEventListener('click', () => setStep(3));

        document.getElementById('hint-btn-2').addEventListener('click', () => {
            document.getElementById('hint-text-2').classList.remove('hidden');
        });
        document.getElementById('next-btn-2').addEventListener('click', () => setStep(3));
        document.getElementById('prev-btn-2').addEventListener('click', () => setStep(1));

        document.getElementById('checkAnswerBtn').addEventListener('click', checkAnswer);
        document.getElementById('next-btn-3').addEventListener('click', () => setStep(5));
        document.getElementById('prev-btn-3').addEventListener('click', () => setStep(2));

        document.getElementById('prev-btn-5').addEventListener('click', () => setStep(3));
        document.getElementById('restart-btn').addEventListener('click', () => {
            currentCount = 0;
            targetCount = 0;
            const input = document.getElementById('pizzaCountInput');
            if (input) input.value = 0;
            if (filledPizza) {
                lPizzaContainer.remove(filledPizza);
                filledPizza = null;
            }
            setStep(0);
        });

        // 실시간 시뮬레이션 입력
        document.getElementById('pizzaCountInput').addEventListener('input', updateVisualization);
        
        // 초기화
        init3D();
        setStep(0);
    </script>
</body>
</html>
